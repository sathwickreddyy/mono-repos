# ============================================================================
# REDIS PRODUCTION CONFIGURATION
# ============================================================================
# Architecture: Message broker + Result backend for Celery task queue
# Persistence: AOF (Append-Only File) for durability
# Performance: Tuned for task queue workload (not cache)
# ============================================================================

# ============================================================================
# NETWORK CONFIGURATION
# ============================================================================
# Bind to all interfaces (required for Docker networking)
# Why 0.0.0.0? Container needs to accept connections from other containers
bind 0.0.0.0

# Disable protected mode (authentication not required for internal network)
# Production recommendation: Enable requirepass for security
protected-mode no

# Port configuration
port 6379

# TCP connection timeout (0 = disabled)
# Why 300s? Close idle connections after 5 minutes to free resources
timeout 300

# TCP backlog (queue of pending connections)
# Higher value = better handling of connection spikes
tcp-backlog 511

# TCP keepalive (send periodic ACKs to detect dead connections)
# Why 300s? Detect network failures within 5 minutes
tcp-keepalive 300

# ============================================================================
# PERSISTENCE: AOF (Append-Only File)
# ============================================================================
# Why AOF for task queue?
# - Every write operation is logged (durability)
# - Tasks survive Redis crashes
# - Trade-off: ~10-15% slower writes vs in-memory only
#
# Alternative: RDB snapshots
# - Faster, but data loss between snapshots
# - Not suitable for financial calculations
# ============================================================================

# Enable AOF persistence
appendonly yes

# AOF filename
appendfilename "appendonly.aof"

# Fsync policy: When to flush writes to disk
# - always: Fsync after every write (slowest, safest, 100% durability)
# - everysec: Fsync every second (balanced, 1s data loss window)
# - no: Let OS decide when to flush (fastest, largest data loss window)
#
# Choice: everysec (best balance for task queue)
# Why? 1-second data loss acceptable vs 10x performance hit of "always"
appendfsync everysec

# Disable fsync during AOF rewrite (prevents blocking)
# Why? AOF rewrite is background process, don't slow down main thread
no-appendfsync-on-rewrite no

# Automatic AOF rewrite triggers (compact log file)
# Why? AOF grows indefinitely without rewrite
# Trigger: When file is 100% larger (2x size) and at least 64MB
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb

# Load truncated AOF file on startup (error recovery)
# Why? Prevents Redis from failing to start after crash
aof-load-truncated yes

# Use RDB-AOF hybrid format (faster loading)
# Why? Combines speed of RDB with durability of AOF
aof-use-rdb-preamble yes

# ============================================================================
# DISABLE RDB SNAPSHOTS
# ============================================================================
# Why? AOF provides persistence, RDB snapshots are redundant overhead
# RDB useful for: Backups, caching (not task queue)
save ""

# Disable RDB compression (not needed since RDB is disabled)
rdbcompression no

# ============================================================================
# MEMORY MANAGEMENT
# ============================================================================
# Max memory limit (prevents OOM killer)
# Why 1GB? Balance between task queue capacity and available RAM
# Calculation: ~1KB per task Ã— 1M tasks = 1GB
maxmemory 1gb

# Eviction policy: What to do when maxmemory is reached
# - noeviction: Return error, don't evict keys (CRITICAL for task queue)
# - allkeys-lru: Evict least recently used keys (good for cache, BAD for queue)
# - volatile-lru: Evict LRU keys with TTL (acceptable for results with expiry)
#
# Choice: noeviction
# Why? Task queue integrity > cache hit rate
# If queue is full, fail fast (circuit breaker) rather than silently drop tasks
maxmemory-policy noeviction

# Memory sampling for LRU (not used with noeviction, but good practice)
maxmemory-samples 5

# ============================================================================
# PERFORMANCE TUNING
# ============================================================================
# Lazy freeing (asynchronous deletion of keys)
# Why? Deleting large keys blocks Redis (single-threaded)
# Trade-off: Slightly delayed memory reclamation vs no blocking
lazyfree-lazy-eviction no
lazyfree-lazy-expire yes
lazyfree-lazy-server-del yes
replica-lazy-flush no

# Active defragmentation (reduce memory fragmentation)
# Why? Long-running Redis can have 30-40% fragmentation
# Trade-off: CPU overhead vs memory efficiency
activedefrag yes
active-defrag-cycle-min 5
active-defrag-cycle-max 75

# ============================================================================
# LOGGING
# ============================================================================
# Log level: debug, verbose, notice, warning
# Why notice? Balance between visibility and disk usage
loglevel notice

# Log to stdout (Docker logs capture it)
# Why empty string? Docker handles log rotation
logfile ""

# Slow log: Track commands taking longer than threshold
# Why 10ms? Detect slow operations that could block Redis
slowlog-log-slower-than 10000
slowlog-max-len 128

# ============================================================================
# SECURITY
# ============================================================================
# Authentication (disabled for internal network)
# Production: Uncomment and set strong password
# requirepass your_strong_password_here

# Disable dangerous commands (production security)
# Why? Prevents accidental data loss from FLUSHALL, CONFIG changes
# rename-command FLUSHDB ""
# rename-command FLUSHALL ""
# rename-command CONFIG ""

# ============================================================================
# REPLICATION (Single instance, but documented for production)
# ============================================================================
# For production high availability:
# 1. Use Redis Sentinel (automatic failover)
# 2. Use Redis Cluster (sharding + replication)
# 3. Or managed service (AWS ElastiCache, Redis Cloud)
#
# Example Sentinel setup:
# - 1 master + 2 replicas
# - 3 Sentinel instances (quorum=2)
# - Auto-failover in <30s

# ============================================================================
# CLIENT LIMITS
# ============================================================================
# Max clients (prevent resource exhaustion)
# Why 10000? 3 API servers + 3 workers + Flower + monitoring = ~10 connections
# But keep headroom for connection spikes
maxclients 10000

# ============================================================================
# MONITORING
# ============================================================================
# Latency monitoring (track slow operations)
# Why? Detect performance degradation early
latency-monitor-threshold 100

# ============================================================================
# RESULT EXPIRATION (Task Results)
# ============================================================================
# Note: Celery sets TTL on result keys via CELERY_RESULT_EXPIRES
# This config sets max TTL (not used with noeviction)
# Celery default: 86400s (1 day)
# Your requirement: 604800s (7 days)
# Configured in docker-compose.yml environment variables
