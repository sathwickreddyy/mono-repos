#!/usr/bin/env python3
"""
Interactive guide to help you understand profilers with real examples.
This script runs demonstrations and shows you what each profiler does.
"""

import subprocess
import sys
import time

def print_header(title):
    print("\n" + "=" * 80)
    print(f" {title}")
    print("=" * 80 + "\n")

def print_profiler_summary():
    """Print a visual summary of all profilers."""
    print("""
    ┌────────────────────────────────────────────────────────────────────────────┐
    │                         PROFILERS IN THIS PROJECT                          │
    └────────────────────────────────────────────────────────────────────────────┘
    
    1. memory-profiler
       ├─ What it profiles: RAM usage per line of code
       ├─ Output: Text report in terminal
       ├─ Use when: Finding memory leaks, optimizing memory usage
       └─ Command: python -m memory_profiler script.py
    
    2. ydata-profiling
       ├─ What it profiles: Dataset statistics and quality
       ├─ Output: Interactive HTML report
       ├─ Use when: Exploring new dataset, data quality checks
       └─ Generated by: pandas_profiling_demo.py
    
    3. py-spy
       ├─ What it profiles: CPU time per function
       ├─ Output: SVG flame graph (interactive)
       ├─ Use when: Finding slow functions, performance bottlenecks
       └─ Command: py-spy record -o output.svg -- python script.py
    
    4. Polars .profile()
       ├─ What it profiles: Query execution plan and timing
       ├─ Output: Text table in terminal
       ├─ Use when: Optimizing Polars queries
       └─ Used in: polars_profiling_demo.py
    
    ┌────────────────────────────────────────────────────────────────────────────┐
    │                         WHAT EACH PROFILER GENERATES                       │
    └────────────────────────────────────────────────────────────────────────────┘
    
    memory-profiler → Terminal Output
    ┌────────────────────────────────────────────────────────────────────────┐
    │ Line #  Mem usage  Increment  Line Contents                            │
    │     47   180.2 MiB   180.2 MiB  @profile                               │
    │     48                          def perform_joins():                    │
    │     49   280.5 MiB   100.3 MiB     df = orders.merge(customers)       │
    │     50   420.8 MiB   140.3 MiB     df = df.merge(products)            │
    └────────────────────────────────────────────────────────────────────────┘
    Shows: Which lines use most memory
    
    
    ydata-profiling → HTML Report (pandas_profile_report.html)
    ┌────────────────────────────────────────────────────────────────────────┐
    │  📊 Dataset Overview                                                   │
    │  ├─ 300,000 rows × 15 columns                                         │
    │  ├─ 5% missing values                                                 │
    │  └─ 0 duplicate rows                                                  │
    │                                                                        │
    │  📈 Variables (each column analyzed)                                   │
    │  ├─ amount: histogram, mean, std, outliers                           │
    │  ├─ status: bar chart, frequencies                                   │
    │  └─ order_date: timeline, date range                                 │
    │                                                                        │
    │  🔗 Correlations                                                       │
    │  └─ Matrix showing relationships between variables                    │
    └────────────────────────────────────────────────────────────────────────┘
    Shows: Complete data analysis and quality report
    
    
    py-spy → Flame Graph (SVG file, open in browser)
    ┌────────────────────────────────────────────────────────────────────────┐
    │                                                                        │
    │  [main] ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  │
    │    └─[load_data] ▓▓▓▓▓▓▓▓                                             │
    │    └─[perform_joins] ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓  ← BOTTLENECK!     │
    │        └─[merge] ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓                                  │
    │    └─[aggregations] ▓▓▓▓▓                                             │
    │                                                                        │
    │  Width = Time spent (wider = slower)                                  │
    └────────────────────────────────────────────────────────────────────────┘
    Shows: Which functions take most CPU time
    
    
    Polars .profile() → Terminal Output
    ┌────────────────────────────────────────────────────────────────────────┐
    │ ╭────────────────────┬────────┬────────────╮                          │
    │ │ node               │ time   │ % of total │                          │
    │ ├────────────────────┼────────┼────────────┤                          │
    │ │ SCAN orders        │ 0.05s  │ 5%         │                          │
    │ │ FILTER             │ 0.03s  │ 3%         │                          │
    │ │ JOIN               │ 0.30s  │ 30%        │ ← Slowest operation      │
    │ │ GROUP BY           │ 0.25s  │ 25%        │                          │
    │ │ COLLECT            │ 0.13s  │ 13%        │                          │
    │ ╰────────────────────┴────────┴────────────╯                          │
    └────────────────────────────────────────────────────────────────────────┘
    Shows: Query execution plan and timing breakdown
    
    """)

def demonstrate_profilers():
    """Interactive demonstration of each profiler."""
    
    print_header("PROFILERS DEMONSTRATION")
    
    demos = [
        {
            'name': '1. Quick Benchmark (No Profiling)',
            'description': 'See raw performance difference between Pandas and Polars',
            'command': 'python quick_benchmark.py',
            'output': 'Terminal output with timing comparison',
            'time': '~5 seconds'
        },
        {
            'name': '2. Memory Profiler',
            'description': 'See RAM usage line-by-line during execution',
            'command': 'python -m memory_profiler pandas_profiling_demo.py',
            'output': 'Terminal with memory usage per line',
            'time': '~20 seconds (slower due to profiling)'
        },
        {
            'name': '3. Data Profiler (ydata-profiling)',
            'description': 'Generate comprehensive HTML report of dataset',
            'command': 'python pandas_profiling_demo.py',
            'output': 'pandas_profile_report.html (open in browser)',
            'time': '~3 minutes (generating HTML report)'
        },
        {
            'name': '4. CPU Profiler (py-spy)',
            'description': 'Generate flame graph showing where time is spent',
            'command': 'py-spy record -o pandas.svg -- python pandas_profiling_demo.py',
            'output': 'pandas.svg (open in browser to see flame graph)',
            'time': '~15 seconds'
        },
        {
            'name': '5. Polars Query Profiler',
            'description': 'See query execution plan and optimization',
            'command': 'python polars_profiling_demo.py',
            'output': 'Terminal with query execution breakdown',
            'time': '~5 seconds'
        }
    ]
    
    for i, demo in enumerate(demos, 1):
        print(f"\n{'─' * 80}")
        print(f"\n{demo['name']}")
        print(f"{'─' * 80}")
        print(f"\n📝 Description: {demo['description']}")
        print(f"⌨️  Command: {demo['command']}")
        print(f"📊 Output: {demo['output']}")
        print(f"⏱️  Time: {demo['time']}")
        
        response = input(f"\nRun this demo? (y/n/q to quit): ").strip().lower()
        
        if response == 'q':
            print("\n👋 Exiting demonstration.")
            break
        elif response == 'y':
            print(f"\n▶️  Running: {demo['command']}\n")
            print("=" * 80)
            
            try:
                subprocess.run(demo['command'], shell=True)
                print("\n" + "=" * 80)
                print(f"✅ Demo {i} completed!\n")
                
                if 'html' in demo['output']:
                    view = input("Open HTML report in browser? (y/n): ").strip().lower()
                    if view == 'y':
                        subprocess.run('open pandas_profile_report.html', shell=True)
                elif '.svg' in demo['output']:
                    view = input("Open flame graph in browser? (y/n): ").strip().lower()
                    if view == 'y':
                        subprocess.run('open pandas.svg', shell=True)
                
            except KeyboardInterrupt:
                print("\n\n⚠️  Demo interrupted by user.")
            except Exception as e:
                print(f"\n❌ Error running demo: {e}")
        else:
            print(f"⏭️  Skipping demo {i}")

def print_learning_path():
    """Print recommended learning path."""
    print_header("RECOMMENDED LEARNING PATH")
    
    print("""
    🎯 BEGINNER PATH (30 minutes)
    ─────────────────────────────────────────────────────────────────────────
    
    Step 1: Understand the basics (5 min)
    └─ Read: PROFILERS_GUIDE.md
    
    Step 2: See performance difference (2 min)
    └─ Run: python quick_benchmark.py
       Learn: Raw speed comparison without profiling
    
    Step 3: Memory profiling basics (10 min)
    └─ Run: python -m memory_profiler pandas_profiling_demo.py
       Learn: How to read memory usage per line
       Look for: Large increments (memory-hungry operations)
    
    Step 4: Data exploration (5 min)
    └─ Run: python pandas_profiling_demo.py
       Open: pandas_profile_report.html
       Learn: Automated data quality analysis
    
    Step 5: CPU profiling basics (8 min)
    └─ Run: py-spy record -o profile.svg -- python pandas_profiling_demo.py
       Open: profile.svg
       Learn: How to read flame graphs
       Look for: Wide bars (slow functions)
    
    
    🚀 INTERMEDIATE PATH (1 hour)
    ─────────────────────────────────────────────────────────────────────────
    
    Step 1: Deep dive into profilers
    └─ Read all sections in PROFILERS_GUIDE.md
    
    Step 2: Compare memory usage
    └─ Run: python -m memory_profiler pandas_profiling_demo.py > pandas_mem.txt
       Run: python -m memory_profiler comparison_demo.py > comparison_mem.txt
       Compare: Memory usage patterns
    
    Step 3: Compare CPU usage
    └─ Run: py-spy record -o pandas.svg -- python pandas_profiling_demo.py
       Run: py-spy record -o polars.svg --native -- python polars_profiling_demo.py
       Compare: Flame graphs side-by-side
    
    Step 4: Understand query optimization
    └─ Run: python polars_profiling_demo.py
       Study: Query execution plan from .profile()
       Notice: Filter pushdown optimization
    
    Step 5: Run complete comparison
    └─ Run: python comparison_demo.py
       Analyze: Performance differences across operations
    
    
    🎓 ADVANCED PATH (2+ hours)
    ─────────────────────────────────────────────────────────────────────────
    
    Step 1: Modify dataset size
    └─ Edit sample_data.py: Change n_orders to 100K, 500K, 1M
       Observe: How profiling results change with scale
    
    Step 2: Add your own profiling
    └─ Add @profile to your own functions
       Profile: Your specific use cases
    
    Step 3: Experiment with optimizations
    └─ Modify: Order of operations in scripts
       Profile: Before and after changes
       Measure: Performance improvements
    
    Step 4: Profile your own data
    └─ Replace: Sample data with your datasets
       Profile: Real-world scenarios
    
    Step 5: Create profiling reports
    └─ Document: Your findings
       Share: Optimization insights with team
    """)

def main():
    """Main function."""
    
    print("\n" + "=" * 80)
    print(" " * 25 + "PROFILERS INTERACTIVE GUIDE")
    print("=" * 80)
    
    while True:
        print("\n\nWhat would you like to do?\n")
        print("1. View profiler summary (quick overview)")
        print("2. Run interactive profiler demonstrations")
        print("3. View recommended learning path")
        print("4. Read comprehensive guide (PROFILERS_GUIDE.md)")
        print("5. Quick reference (help.py)")
        print("6. Exit")
        
        choice = input("\nEnter your choice (1-6): ").strip()
        
        if choice == '1':
            print_profiler_summary()
            input("\nPress Enter to continue...")
            
        elif choice == '2':
            demonstrate_profilers()
            input("\nPress Enter to continue...")
            
        elif choice == '3':
            print_learning_path()
            input("\nPress Enter to continue...")
            
        elif choice == '4':
            subprocess.run('cat PROFILERS_GUIDE.md | less', shell=True)
            
        elif choice == '5':
            subprocess.run('python help.py', shell=True)
            input("\nPress Enter to continue...")
            
        elif choice == '6':
            print("\n👋 Happy profiling! Check PROFILERS_GUIDE.md for details.\n")
            break
            
        else:
            print("\n❌ Invalid choice. Please enter 1-6.")

if __name__ == "__main__":
    main()
